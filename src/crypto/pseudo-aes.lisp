;;;; This file is part of monero-tools
;;;; Copyright 2018 Guillaume LE VAILLANT
;;;; Distributed under the GNU GPL v3 or later.
;;;; See the file LICENSE for terms of use and distribution.


#+(and sbcl x86-64 aes-ni)
(in-package :sb-c)
#+(and sbcl x86-64 aes-ni)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defknown monero-tools::pseudo-aes-expand-key/aes-ni
    ((simple-array (unsigned-byte 8) (*))
     (simple-array (unsigned-byte 32) (*)))
    (values)
    (any)
    :overwrite-fndb-silently t)

  (defknown monero-tools::pseudo-aes-round/aes-ni
    ((simple-array (unsigned-byte 8) (*))
     (unsigned-byte 32)
     (simple-array (unsigned-byte 8) (*))
     (unsigned-byte 32)
     (simple-array (unsigned-byte 8) (*)))
    (values)
    (any)
    :overwrite-fndb-silently t)

  (defknown monero-tools::pseudo-aes-rounds/aes-ni
    ((simple-array (unsigned-byte 8) (*))
     (unsigned-byte 32)
     (simple-array (unsigned-byte 8) (*))
     (unsigned-byte 32)
     (simple-array (unsigned-byte 32) (*)))
    (values)
    (any)
    :overwrite-fndb-silently t))

#+(and sbcl x86-64 aes-ni)
(in-package :sb-vm)
#+(and sbcl x86-64 aes-ni)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (define-vop (pseudo-aes-expand-key/aes-ni)
    (:translate monero-tools::pseudo-aes-expand-key/aes-ni)
    (:policy :fast-safe)
    (:args (key :scs (descriptor-reg))
           (encryption-keys :scs (descriptor-reg)))
    (:arg-types simple-array-unsigned-byte-8
                simple-array-unsigned-byte-32)
    (:temporary (:sc double-reg) x0 x1 x2 x3)
    (:generator 1000
      (flet ((ea (base i)
               (make-ea :qword
                        :base base
                        :disp (+ (- (* n-word-bytes vector-data-offset)
                                    other-pointer-lowtag)
                                 (* 16 i)))))
        (macrolet ((expand-key-256a ()
                     `(progn
                        (inst pshufd x1 x1 #b11111111)
                        (inst shufps x2 x0 #b00010000)
                        (inst pxor x0 x2)
                        (inst shufps x2 x0 #b10001100)
                        (inst pxor x0 x2)
                        (inst pxor x0 x1)))
                   (expand-key-256b ()
                     `(progn
                        (inst pshufd x1 x1 #b10101010)
                        (inst shufps x2 x3 #b00010000)
                        (inst pxor x3 x2)
                        (inst shufps x2 x3 #b10001100)
                        (inst pxor x3 x2)
                        (inst pxor x3 x1))))
          (inst pxor x2 x2)
          (inst movdqa x0 (ea key 0))
          (inst movdqa x3 (ea key 1))
          (inst movdqa (ea encryption-keys 0) x0)
          (inst movdqa (ea encryption-keys 1) x3)
          (inst aeskeygenassist x1 x3 1)
          (expand-key-256a)
          (inst movdqa (ea encryption-keys 2) x0)
          (inst aeskeygenassist x1 x0 1)
          (expand-key-256b)
          (inst movdqa (ea encryption-keys 3) x3)
          (inst aeskeygenassist x1 x3 2)
          (expand-key-256a)
          (inst movdqa (ea encryption-keys 4) x0)
          (inst aeskeygenassist x1 x0 2)
          (expand-key-256b)
          (inst movdqa (ea encryption-keys 5) x3)
          (inst aeskeygenassist x1 x3 4)
          (expand-key-256a)
          (inst movdqa (ea encryption-keys 6) x0)
          (inst aeskeygenassist x1 x0 4)
          (expand-key-256b)
          (inst movdqa (ea encryption-keys 7) x3)
          (inst aeskeygenassist x1 x3 8)
          (expand-key-256a)
          (inst movdqa (ea encryption-keys 8) x0)
          (inst aeskeygenassist x1 x0 8)
          (expand-key-256b)
          (inst movdqa (ea encryption-keys 9) x3)))))

  (define-vop (pseudo-aes-round/aes-ni)
    (:translate monero-tools::pseudo-aes-round/aes-ni)
    (:policy :fast-safe)
    (:args (in :scs (descriptor-reg))
           (in-start :scs (unsigned-reg))
           (out :scs (descriptor-reg))
           (out-start :scs (unsigned-reg))
           (round-key :scs (descriptor-reg)))
    (:arg-types simple-array-unsigned-byte-8
                unsigned-num
                simple-array-unsigned-byte-8
                unsigned-num
                simple-array-unsigned-byte-8)
    (:temporary (:sc double-reg) x0 x1)
    (:generator 1000
      (flet ((buffer-mem (base offset)
               (make-ea :qword
                        :base base
                        :index offset
                        :disp (- (* n-word-bytes vector-data-offset)
                                 other-pointer-lowtag)))
             (round-key ()
               (make-ea :qword
                        :base round-key
                        :disp (- (* n-word-bytes vector-data-offset)
                                 other-pointer-lowtag))))
        (inst movdqa x0 (buffer-mem in in-start))
        (inst movdqa x1 (round-key))
        (inst aesenc x0 x1)
        (inst movdqa (buffer-mem out out-start) x0))))

  (define-vop (pseudo-aes-rounds/aes-ni)
    (:translate monero-tools::pseudo-aes-rounds/aes-ni)
    (:policy :fast-safe)
    (:args (in :scs (descriptor-reg))
           (in-start :scs (unsigned-reg))
           (out :scs (descriptor-reg))
           (out-start :scs (unsigned-reg))
           (round-keys :scs (descriptor-reg)))
    (:arg-types simple-array-unsigned-byte-8
                unsigned-num
                simple-array-unsigned-byte-8
                unsigned-num
                simple-array-unsigned-byte-32)
    (:temporary (:sc double-reg) x0 x1)
    (:generator 1000
      (flet ((buffer-mem (base offset)
               (make-ea :qword
                        :base base
                        :index offset
                        :disp (- (* n-word-bytes vector-data-offset)
                                 other-pointer-lowtag)))
             (round-key (i)
               (make-ea :qword
                        :base round-keys
                        :disp (+ (- (* n-word-bytes vector-data-offset)
                                    other-pointer-lowtag)
                                 (* 16 i)))))
        (inst movdqa x0 (buffer-mem in in-start))
        (inst movdqa x1 (round-key 0))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 1))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 2))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 3))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 4))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 5))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 6))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 7))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 8))
        (inst aesenc x0 x1)
        (inst movdqa x1 (round-key 9))
        (inst aesenc x0 x1)
        (inst movdqa (buffer-mem out out-start) x0)))))


(in-package :monero-tools)


(defun pseudo-aes-expand-key (state state-start)
  (declare (type (simple-array (unsigned-byte 8) (*)) state)
           (type fixnum state-start)
           (optimize (speed 3) (space 0) (safety 0) (debug 0)))
  (let* ((key (make-array 32 :element-type '(unsigned-byte 8)))
         (encryption-keys (ironclad::allocate-round-keys key)))
    (declare (type (simple-array (unsigned-byte 8) (32)) key)
             (type ironclad::aes-round-keys encryption-keys)
             (dynamic-extent key))
    (replace key state :start2 state-start)
    #+(and sbcl x86-64 aes-ni)
    (pseudo-aes-expand-key/aes-ni key encryption-keys)
    #-(and sbcl x86-64 aes-ni)
    (ironclad::generate-round-keys-for-encryption key encryption-keys)
    encryption-keys))

(macrolet ((rk-ref (x)
             `(aref round-keys ,x))
           (mix (rk a0 a1 a2 a3 sym0 sym1 sym2 sym3)
             `(logxor (aref ,a0 (ironclad::fourth-byte ,sym0))
                      (aref ,a1 (ironclad::third-byte ,sym1))
                      (aref ,a2 (ironclad::second-byte ,sym2))
                      (aref ,a3 (ironclad::first-byte ,sym3))
                      (rk-ref ,rk)))
           (mix-s-into-t-encrypting (offset)
             `(setf t0 (mix ,offset ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 s0 s1 s2 s3)
                    t1 (mix ,(1+ offset) ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 s1 s2 s3 s0)
                    t2 (mix ,(+ offset 2) ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 s2 s3 s0 s1)
                    t3 (mix ,(+ offset 3) ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 s3 s0 s1 s2)))
           (mix-t-into-s-encrypting (offset)
             `(setf s0 (mix ,offset ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 t0 t1 t2 t3)
                    s1 (mix ,(1+ offset) ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 t1 t2 t3 t0)
                    s2 (mix ,(+ offset 2) ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 t2 t3 t0 t1)
                    s3 (mix ,(+ offset 3) ironclad::Te0 ironclad::Te1 ironclad::Te2 ironclad::Te3 t3 t0 t1 t2))))
  (defun pseudo-aes-round (in in-start out out-start round-key)
    (declare (type (simple-array (unsigned-byte 8) (*)) in out)
             (type (simple-array (unsigned-byte 8) (16)) round-key)
             (type (unsigned-byte 32) in-start out-start)
             (optimize (speed 3) (space 0) (safety 0) (debug 0)))
    #+(and sbcl x86-64 aes-ni)
    (pseudo-aes-round/aes-ni in in-start out out-start round-key)
    #-(and sbcl x86-64 aes-ni)
    (let ((round-keys (make-array 4 :element-type '(unsigned-byte 32))))
      (declare (type (simple-array (unsigned-byte 32) (4)) round-keys)
               (dynamic-extent round-keys))
      (setf (aref round-keys 0) (ub32ref/be round-key 0))
      (setf (aref round-keys 1) (ub32ref/be round-key 4))
      (setf (aref round-keys 2) (ub32ref/be round-key 8))
      (setf (aref round-keys 3) (ub32ref/be round-key 12))
      (ironclad::with-words ((s0 s1 s2 s3) in in-start)
        (let ((t0 0) (t1 0) (t2 0) (t3 0))
          (declare (type (unsigned-byte 32) t0 t1 t2 t3))
          (mix-s-into-t-encrypting 0)
          (ironclad::store-words out out-start t0 t1 t2 t3)))))

  (defun pseudo-aes-rounds (in in-start out out-start round-keys)
    (declare (type (simple-array (unsigned-byte 8) (*)) in out)
             (type ironclad::aes-round-keys round-keys)
             (type (unsigned-byte 32) in-start out-start)
             (optimize (speed 3) (space 0) (safety 0) (debug 0)))
    #+(and sbcl x86-64 aes-ni)
    (pseudo-aes-rounds/aes-ni in in-start out out-start round-keys)
    #-(and sbcl x86-64 aes-ni)
    (ironclad::with-words ((s0 s1 s2 s3) in in-start)
      (let ((t0 0) (t1 0) (t2 0) (t3 0))
        (declare (type (unsigned-byte 32) t0 t1 t2 t3))
        (mix-s-into-t-encrypting 0)
        (mix-t-into-s-encrypting 4)
        (mix-s-into-t-encrypting 8)
        (mix-t-into-s-encrypting 12)
        (mix-s-into-t-encrypting 16)
        (mix-t-into-s-encrypting 20)
        (mix-s-into-t-encrypting 24)
        (mix-t-into-s-encrypting 28)
        (mix-s-into-t-encrypting 32)
        (mix-t-into-s-encrypting 36)
        (ironclad::store-words out out-start s0 s1 s2 s3)))))
